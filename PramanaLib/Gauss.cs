using System.Numerics;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json.Serialization;

namespace PramanaLib;

/// <summary>
/// C# implementation of the <c>num:</c> pseudo-class from the Pramana knowledge graph.
/// Represents a Gaussian rational number — a complex number whose real and imaginary
/// parts are both rational numbers — stored as the normalized vector
/// &lt;A, B, C, D&gt; representing the value A/B + (C/D)i, where A, B, C, D are
/// <see cref="BigInteger"/> values and all fractions are kept in lowest terms with
/// positive denominators.
/// <para>
/// In Pramana, <c>num:</c> is a deterministic pseudo-class: any value written as
/// <c>num:a,b,c,d</c> (or short forms <c>num:a</c>, <c>num:a,b</c>) is automatically
/// canonicalized, classified in the number hierarchy (Natural Number, Whole Number,
/// Integer, Rational Number, Gaussian Rational, etc.), and assigned a stable UUID v5
/// via <see cref="PramanaId"/>. This struct provides the C# runtime for that scheme,
/// giving exact arithmetic, formatting, and identity generation that stays consistent
/// with the Python implementation in <c>src/combinatoric_classes.py</c>.
/// </para>
/// <para>
/// This type is an immutable value type (readonly struct) designed for exact arithmetic
/// without floating-point precision loss. Methods that would produce irrational results
/// (e.g. <see cref="Magnitude"/>, <see cref="Phase"/>) throw
/// <see cref="NotSupportedException"/> by design.
/// </para>
/// </summary>
/// <remarks>
/// <list type="bullet">
///   <item>Supports implicit conversion from <see cref="int"/>, <see cref="long"/>,
///     <see cref="BigInteger"/>, <see cref="float"/>, <see cref="double"/>, and
///     <see cref="decimal"/>.</item>
///   <item>Supports explicit conversion to <see cref="int"/>, <see cref="long"/>,
///     <see cref="BigInteger"/>, <see cref="float"/>, <see cref="double"/>,
///     <see cref="decimal"/>, and array types.</item>
///   <item>Implements full arithmetic (+, -, *, /, %), comparison, equality,
///     <see cref="IFormattable"/>, and parsing.</item>
///   <item>The <see cref="PramanaId"/> for a value matches the UUID v5 generated by the
///     Pramana web app for the same canonical <c>num:</c> string, using the shared
///     namespace <c>a6613321-e9f6-4348-8f8b-29d2a3c86349</c>.</item>
/// </list>
/// </remarks>
[Serializable]
public readonly struct Gauss :
    IEquatable<Gauss>,
    IComparable<Gauss>,
    IComparable,
    IFormattable
{
    /// <summary>
    /// The UUID v5 namespace for the <c>num:</c> pseudo-class, shared with the Pramana
    /// Python codebase (<c>NUM_NAMESPACE</c> in <c>web/app.py</c>).
    /// </summary>
    internal static readonly Guid PramanaNamespace = new("a6613321-e9f6-4348-8f8b-29d2a3c86349");

    /// <summary>Gets the numerator of the real part (A in A/B).</summary>
    public BigInteger A { get; }

    /// <summary>Gets the denominator of the real part (B in A/B). Always positive.</summary>
    public BigInteger B { get; }

    /// <summary>Gets the numerator of the imaginary part (C in C/D).</summary>
    public BigInteger C { get; }

    /// <summary>Gets the denominator of the imaginary part (D in C/D). Always positive.</summary>
    public BigInteger D { get; }

    /// <summary>
    /// Initializes a new <see cref="Gauss"/> representing the value
    /// <paramref name="a"/>/<paramref name="b"/> + (<paramref name="c"/>/<paramref name="d"/>)i.
    /// Both fractions are automatically reduced to lowest terms with positive denominators.
    /// </summary>
    /// <param name="a">Numerator of the real part.</param>
    /// <param name="b">Denominator of the real part. Must not be zero.</param>
    /// <param name="c">Numerator of the imaginary part.</param>
    /// <param name="d">Denominator of the imaginary part. Must not be zero.</param>
    /// <exception cref="DivideByZeroException">
    /// Thrown when <paramref name="b"/> or <paramref name="d"/> is zero.
    /// </exception>
    public Gauss(BigInteger a, BigInteger b, BigInteger c, BigInteger d)
    {
        if (b == 0) throw new DivideByZeroException("Real denominator cannot be zero");
        if (d == 0) throw new DivideByZeroException("Imaginary denominator cannot be zero");

        // Normalize real part
        (A, B) = Normalize(a, b);
        // Normalize imaginary part
        (C, D) = Normalize(c, d);
    }

    /// <summary>
    /// Initializes a new <see cref="Gauss"/> from integer real and imaginary parts,
    /// representing the value <paramref name="real"/> + <paramref name="imaginary"/>*i.
    /// </summary>
    /// <param name="real">The integer real part.</param>
    /// <param name="imaginary">The integer imaginary coefficient.</param>
    public Gauss(BigInteger real, BigInteger imaginary) : this(real, 1, imaginary, 1) { }

    /// <summary>
    /// Initializes a new <see cref="Gauss"/> from a single integer value
    /// (imaginary part is zero).
    /// </summary>
    /// <param name="value">The integer value.</param>
    public Gauss(BigInteger value) : this(value, 1, 0, 1) { }

    /// <summary>
    /// Reduces a fraction to lowest terms, ensuring a positive denominator.
    /// A zero numerator always normalizes to 0/1.
    /// </summary>
    private static (BigInteger num, BigInteger den) Normalize(BigInteger numerator, BigInteger denominator)
    {
        if (denominator == 0) throw new DivideByZeroException();

        // Handle zero numerator
        if (numerator == 0) return (0, 1);

        // Ensure denominator is positive
        if (denominator < 0)
        {
            numerator = -numerator;
            denominator = -denominator;
        }

        // Reduce to lowest terms
        var gcd = BigInteger.GreatestCommonDivisor(BigInteger.Abs(numerator), denominator);
        return (numerator / gcd, denominator / gcd);
    }

    /// <summary>
    /// Gets a deterministic UUID v5 that uniquely identifies this value.
    /// Generated by hashing the canonical string "A,B,C,D" under the
    /// <see cref="PramanaNamespace"/>. Two <see cref="Gauss"/> values
    /// that are mathematically equal will always produce the same ID.
    /// </summary>
    public Guid PramanaId => GenerateUuidV5(PramanaNamespace, $"{A},{B},{C},{D}");

    /// <summary>
    /// Gets the canonical Pramana pseudo-class string for this number, in the form
    /// <c>pra:num:A,B,C,D</c> (e.g. <c>"pra:num:1,1,0,1"</c> for 1,
    /// <c>"pra:num:3,1,2,1"</c> for 3+2i).
    /// </summary>
    public string PramanaString => $"pra:num:{A},{B},{C},{D}";

    /// <summary>
    /// Gets the Pramana entity URL using the hashed UUID v5 identifier, formed as
    /// <c>https://pramana-data.ca/entity/{PramanaId}</c>.
    /// </summary>
    public string PramanaHashUrl => $"https://pramana-data.ca/entity/{PramanaId}";

    /// <summary>
    /// Gets the Pramana entity URL using the non-hashed pseudo-class string, formed as
    /// <c>https://pramana-data.ca/entity/pra:num:A,B,C,D</c>.
    /// </summary>
    public string PramanaUrl => $"https://pramana-data.ca/entity/{PramanaString}";

    /// <summary>
    /// Generates a UUID v5 by SHA-1-hashing <paramref name="name"/> within the given
    /// <paramref name="namespaceId"/>, per RFC 4122.
    /// </summary>
    internal static Guid GenerateUuidV5(Guid namespaceId, string name)
    {
        byte[] namespaceBytes = namespaceId.ToByteArray();
        // Convert to big-endian for UUID spec compliance
        SwapByteOrder(namespaceBytes);

        byte[] nameBytes = Encoding.UTF8.GetBytes(name);
        byte[] data = new byte[namespaceBytes.Length + nameBytes.Length];
        namespaceBytes.CopyTo(data, 0);
        nameBytes.CopyTo(data, namespaceBytes.Length);

        byte[] hash = SHA1.HashData(data);

        byte[] result = new byte[16];
        Array.Copy(hash, 0, result, 0, 16);

        // Set version (5) and variant bits
        result[6] = (byte)((result[6] & 0x0F) | 0x50);
        result[8] = (byte)((result[8] & 0x3F) | 0x80);

        SwapByteOrder(result);
        return new Guid(result);
    }

    /// <summary>
    /// Swaps the byte order of the first three components of a GUID byte array
    /// between little-endian (.NET) and big-endian (UUID spec) representations.
    /// </summary>
    private static void SwapByteOrder(byte[] guid)
    {
        (guid[0], guid[3]) = (guid[3], guid[0]);
        (guid[1], guid[2]) = (guid[2], guid[1]);
        (guid[4], guid[5]) = (guid[5], guid[4]);
        (guid[6], guid[7]) = (guid[7], guid[6]);
    }

    #region String Representations

    /// <summary>
    /// Returns the internal vector representation as a string in the form
    /// <c>&lt;A,B,C,D&gt;</c> (e.g. <c>&lt;3,2,1,4&gt;</c> for 3/2 + 1/4 i).
    /// </summary>
    public string ToRawString() => $"<{A},{B},{C},{D}>";

    /// <summary>
    /// Returns a human-readable string using mixed-fraction notation.
    /// <para>Examples: <c>"0"</c>, <c>"1/2"</c>, <c>"1 &amp; 1/2"</c>,
    /// <c>"3 + 2i"</c>, <c>"1/2 - 1/3 i"</c>.</para>
    /// </summary>
    public override string ToString()
    {
        string realPart = FormatRational(A, B);
        string imagPart = FormatImaginary(C, D);

        if (C == 0) return realPart;
        if (A == 0) return imagPart;

        if (C > 0)
            return $"{realPart} + {imagPart}";
        else
            return $"{realPart} - {FormatImaginary(-C, D)}";
    }

    /// <summary>
    /// Returns a decimal approximation string with the specified number of decimal places.
    /// </summary>
    /// <param name="precision">The number of decimal places (default 15).</param>
    /// <returns>
    /// A decimal approximation such as <c>"1.5 + 0.333333333333333i"</c>.
    /// </returns>
    public string ToDecimalString(int precision = 15)
    {
        double re = (double)A / (double)B;
        double im = (double)C / (double)D;

        string rePart = re.ToString($"F{precision}");
        if (C == 0) return rePart;

        string imAbs = Math.Abs(im).ToString($"F{precision}");
        if (A == 0)
        {
            if (im < 0) return $"-{imAbs}i";
            return $"{imAbs}i";
        }

        if (im < 0)
            return $"{rePart} - {imAbs}i";
        return $"{rePart} + {imAbs}i";
    }

    /// <summary>
    /// Formats a rational number as a mixed fraction string.
    /// Whole numbers display without a denominator; proper fractions as "n/d";
    /// improper fractions as "w &amp; r/d" (e.g. "1 &amp; 1/2").
    /// </summary>
    private static string FormatRational(BigInteger num, BigInteger den)
    {
        if (den == 1) return num.ToString();

        // Use mixed fraction format: "1 & 1/2" instead of "3/2"
        BigInteger whole = num / den;
        BigInteger remainder = BigInteger.Abs(num % den);

        if (whole == 0)
        {
            // Proper fraction only (e.g., "1/2" or "-1/2")
            return $"{num}/{den}";
        }

        if (remainder == 0)
        {
            // Whole number
            return whole.ToString();
        }

        // Mixed fraction (e.g., "1 & 1/2" or "-1 & 1/2")
        return $"{whole} & {remainder}/{den}";
    }

    /// <summary>
    /// Formats the imaginary coefficient as a mixed fraction followed by "i".
    /// Special cases: ±1 renders as "i"/"-i"; zero renders as "0".
    /// </summary>
    private static string FormatImaginary(BigInteger num, BigInteger den)
    {
        if (num == 0) return "0";
        if (num == 1 && den == 1) return "i";
        if (num == -1 && den == 1) return "-i";
        if (den == 1) return $"{num}i";

        // Use mixed fraction format for imaginary part
        BigInteger whole = num / den;
        BigInteger remainder = BigInteger.Abs(num % den);

        if (whole == 0)
        {
            // Proper fraction only
            return $"{num}/{den} i";
        }

        if (remainder == 0)
        {
            // Whole number
            return $"{whole}i";
        }

        // Mixed fraction
        return $"{whole} & {remainder}/{den} i";
    }

    #endregion

    #region Implicit Conversions (FROM other types)

    /// <summary>Implicitly converts an <see cref="int"/> to a real <see cref="Gauss"/>.</summary>
    public static implicit operator Gauss(int value) => new(value);

    /// <summary>Implicitly converts a <see cref="long"/> to a real <see cref="Gauss"/>.</summary>
    public static implicit operator Gauss(long value) => new(value);

    /// <summary>Implicitly converts a <see cref="BigInteger"/> to a real <see cref="Gauss"/>.</summary>
    public static implicit operator Gauss(BigInteger value) => new(value);

    /// <summary>
    /// Implicitly converts a <see cref="float"/> to a <see cref="Gauss"/>
    /// using a continued-fraction algorithm for the best rational approximation.
    /// </summary>
    public static implicit operator Gauss(float value) => FromDouble(value);

    /// <summary>
    /// Implicitly converts a <see cref="double"/> to a <see cref="Gauss"/>
    /// using a continued-fraction algorithm for the best rational approximation.
    /// </summary>
    public static implicit operator Gauss(double value) => FromDouble(value);

    /// <summary>
    /// Implicitly converts a <see cref="decimal"/> to a <see cref="Gauss"/>
    /// by extracting the exact mantissa and scale.
    /// </summary>
    public static implicit operator Gauss(decimal value) => FromDecimal(value);

    /// <summary>
    /// Converts a <see cref="double"/> to a <see cref="Gauss"/> by computing the
    /// best rational approximation via the continued-fraction algorithm.
    /// </summary>
    /// <exception cref="ArgumentException">
    /// Thrown when <paramref name="value"/> is NaN or Infinity.
    /// </exception>
    private static Gauss FromDouble(double value)
    {
        if (double.IsNaN(value) || double.IsInfinity(value))
            throw new ArgumentException("Cannot convert NaN or Infinity to Gauss");

        // Convert to exact fraction representation
        var (num, den) = DoubleToFraction(value);
        return new Gauss(num, den, 0, 1);
    }

    /// <summary>
    /// Converts a <see cref="decimal"/> to a <see cref="Gauss"/> by extracting
    /// the exact mantissa and power-of-10 scale from the decimal's binary representation.
    /// This conversion is lossless.
    /// </summary>
    private static Gauss FromDecimal(decimal value)
    {
        // Get the bits of the decimal
        int[] bits = decimal.GetBits(value);
        int scale = (bits[3] >> 16) & 0xFF;
        bool negative = (bits[3] & 0x80000000) != 0;

        // Construct the mantissa
        BigInteger mantissa = new BigInteger((uint)bits[2]);
        mantissa = (mantissa << 32) | (uint)bits[1];
        mantissa = (mantissa << 32) | (uint)bits[0];

        if (negative) mantissa = -mantissa;

        BigInteger denominator = BigInteger.Pow(10, scale);
        return new Gauss(mantissa, denominator, 0, 1);
    }

    /// <summary>
    /// Computes the best rational approximation of a non-negative <see cref="double"/>
    /// using the continued-fraction algorithm, stopping when the approximation is within
    /// a relative tolerance of 1e-15 or after 64 iterations.
    /// </summary>
    private static (BigInteger num, BigInteger den) DoubleToFraction(double value)
    {
        if (value == 0) return (0, 1);

        bool negative = value < 0;
        value = Math.Abs(value);

        // Use continued fraction algorithm for best rational approximation
        const double tolerance = 1e-15;
        const int maxIterations = 64;

        BigInteger num1 = 1, num2 = 0;
        BigInteger den1 = 0, den2 = 1;
        double x = value;

        for (int i = 0; i < maxIterations; i++)
        {
            BigInteger intPart = (BigInteger)Math.Floor(x);
            BigInteger num = intPart * num1 + num2;
            BigInteger den = intPart * den1 + den2;

            double approx = (double)num / (double)den;
            if (Math.Abs(approx - value) < tolerance * value)
            {
                return (negative ? -num : num, den);
            }

            num2 = num1; num1 = num;
            den2 = den1; den1 = den;

            double frac = x - (double)intPart;
            if (frac < tolerance) break;
            x = 1.0 / frac;
        }

        return (negative ? -num1 : num1, den1);
    }

    #endregion

    #region Explicit Conversions (TO other types)

    /// <summary>
    /// Throws <see cref="InvalidCastException"/> if this value has a non-zero imaginary part.
    /// Used as a guard for conversions to real numeric types.
    /// </summary>
    private void ThrowIfNotReal()
    {
        if (C != 0)
            throw new InvalidCastException("Cannot convert complex number with non-zero imaginary part to real number type");
    }

    /// <summary>
    /// Explicitly converts to <see cref="int"/>. The value must be a real integer.
    /// </summary>
    /// <exception cref="InvalidCastException">Thrown if the value has a non-zero imaginary part or is not an integer.</exception>
    public static explicit operator int(Gauss gr)
    {
        gr.ThrowIfNotReal();
        if (gr.B != 1)
            throw new InvalidCastException($"Cannot convert non-integer rational {gr.A}/{gr.B} to int");
        return (int)gr.A;
    }

    /// <summary>
    /// Explicitly converts to <see cref="long"/>. The value must be a real integer.
    /// </summary>
    /// <exception cref="InvalidCastException">Thrown if the value has a non-zero imaginary part or is not an integer.</exception>
    public static explicit operator long(Gauss gr)
    {
        gr.ThrowIfNotReal();
        if (gr.B != 1)
            throw new InvalidCastException($"Cannot convert non-integer rational {gr.A}/{gr.B} to long");
        return (long)gr.A;
    }

    /// <summary>
    /// Explicitly converts to <see cref="BigInteger"/>. The value must be a real integer.
    /// </summary>
    /// <exception cref="InvalidCastException">Thrown if the value has a non-zero imaginary part or is not an integer.</exception>
    public static explicit operator BigInteger(Gauss gr)
    {
        gr.ThrowIfNotReal();
        if (gr.B != 1)
            throw new InvalidCastException($"Cannot convert non-integer rational {gr.A}/{gr.B} to BigInteger");
        return gr.A;
    }

    /// <summary>
    /// Explicitly converts to <see cref="float"/> by dividing numerator by denominator.
    /// The value must be real; precision may be lost.
    /// </summary>
    /// <exception cref="InvalidCastException">Thrown if the value has a non-zero imaginary part.</exception>
    public static explicit operator float(Gauss gr)
    {
        gr.ThrowIfNotReal();
        return (float)gr.A / (float)gr.B;
    }

    /// <summary>
    /// Explicitly converts to <see cref="double"/> by dividing numerator by denominator.
    /// The value must be real; precision may be lost.
    /// </summary>
    /// <exception cref="InvalidCastException">Thrown if the value has a non-zero imaginary part.</exception>
    public static explicit operator double(Gauss gr)
    {
        gr.ThrowIfNotReal();
        return (double)gr.A / (double)gr.B;
    }

    /// <summary>
    /// Explicitly converts to <see cref="decimal"/> by dividing numerator by denominator.
    /// The value must be real; precision may be lost for very large values.
    /// </summary>
    /// <exception cref="InvalidCastException">Thrown if the value has a non-zero imaginary part.</exception>
    public static explicit operator decimal(Gauss gr)
    {
        gr.ThrowIfNotReal();
        return (decimal)gr.A / (decimal)gr.B;
    }

    /// <summary>
    /// Converts to array [real, imaginary] as doubles.
    /// </summary>
    public static explicit operator double[](Gauss gr)
    {
        return [(double)gr.A / (double)gr.B, (double)gr.C / (double)gr.D];
    }

    /// <summary>
    /// Converts to array [real, imaginary] as integers (throws if not integer values).
    /// </summary>
    public static explicit operator int[](Gauss gr)
    {
        if (gr.B != 1 || gr.D != 1)
            throw new InvalidCastException("Cannot convert non-integer Gauss to int[]");
        return [(int)gr.A, (int)gr.C];
    }

    /// <summary>
    /// Converts to array [real, imaginary] as BigIntegers (throws if not integer values).
    /// </summary>
    public static explicit operator BigInteger[](Gauss gr)
    {
        if (gr.B != 1 || gr.D != 1)
            throw new InvalidCastException("Cannot convert non-integer Gauss to BigInteger[]");
        return [gr.A, gr.C];
    }

    #endregion

    #region Mathematical Operations

    /// <summary>
    /// Adds two <see cref="Gauss"/> values by independently adding their
    /// real and imaginary rational parts.
    /// </summary>
    public static Gauss operator +(Gauss left, Gauss right)
    {
        // (a/b + c/d*i) + (e/f + g/h*i) = (a/b + e/f) + (c/d + g/h)*i
        var (realNum, realDen) = AddFractions(left.A, left.B, right.A, right.B);
        var (imagNum, imagDen) = AddFractions(left.C, left.D, right.C, right.D);
        return new Gauss(realNum, realDen, imagNum, imagDen);
    }

    /// <summary>
    /// Subtracts <paramref name="right"/> from <paramref name="left"/> by independently
    /// subtracting their real and imaginary rational parts.
    /// </summary>
    public static Gauss operator -(Gauss left, Gauss right)
    {
        var (realNum, realDen) = AddFractions(left.A, left.B, -right.A, right.B);
        var (imagNum, imagDen) = AddFractions(left.C, left.D, -right.C, right.D);
        return new Gauss(realNum, realDen, imagNum, imagDen);
    }

    /// <summary>
    /// Returns the additive inverse (negation) of the value, negating both real and
    /// imaginary parts.
    /// </summary>
    public static Gauss operator -(Gauss value)
    {
        return new Gauss(-value.A, value.B, -value.C, value.D);
    }

    /// <summary>Increments the real part by one.</summary>
    public static Gauss operator ++(Gauss value)
    {
        return value + One;
    }

    /// <summary>Decrements the real part by one.</summary>
    public static Gauss operator --(Gauss value)
    {
        return value - One;
    }

    /// <summary>
    /// Multiplies two <see cref="Gauss"/> values using the standard complex
    /// multiplication formula: (a+bi)(c+di) = (ac−bd) + (ad+bc)i, with all intermediate
    /// arithmetic performed in exact rational form.
    /// </summary>
    public static Gauss operator *(Gauss left, Gauss right)
    {
        // (a + bi)(c + di) = (ac - bd) + (ad + bc)i
        // With fractions: (a/b + c/d*i)(e/f + g/h*i)
        // Real: (a/b)(e/f) - (c/d)(g/h) = ae/bf - cg/dh
        // Imag: (a/b)(g/h) + (c/d)(e/f) = ag/bh + ce/df

        var (r1Num, r1Den) = MultiplyFractions(left.A, left.B, right.A, right.B);
        var (r2Num, r2Den) = MultiplyFractions(left.C, left.D, right.C, right.D);
        var (realNum, realDen) = AddFractions(r1Num, r1Den, -r2Num, r2Den);

        var (i1Num, i1Den) = MultiplyFractions(left.A, left.B, right.C, right.D);
        var (i2Num, i2Den) = MultiplyFractions(left.C, left.D, right.A, right.B);
        var (imagNum, imagDen) = AddFractions(i1Num, i1Den, i2Num, i2Den);

        return new Gauss(realNum, realDen, imagNum, imagDen);
    }

    /// <summary>
    /// Divides <paramref name="left"/> by <paramref name="right"/> using conjugate
    /// multiplication: (a+bi)/(c+di) = (a+bi)(c−di) / (c²+d²).
    /// </summary>
    /// <exception cref="DivideByZeroException">Thrown when <paramref name="right"/> is zero.</exception>
    public static Gauss operator /(Gauss left, Gauss right)
    {
        // (a + bi)/(c + di) = (a + bi)(c - di) / (c² + d²)
        var conjugate = right.Conjugate;
        var numerator = left * conjugate;
        var denominator = right * conjugate; // This will be real (c² + d²)

        // denominator.C should be 0, denominator is (c² + d²)/1
        if (denominator.A == 0)
            throw new DivideByZeroException("Cannot divide by zero");

        // Divide numerator by denominator (which is real)
        var (realNum, realDen) = DivideFractions(numerator.A, numerator.B, denominator.A, denominator.B);
        var (imagNum, imagDen) = DivideFractions(numerator.C, numerator.D, denominator.A, denominator.B);

        return new Gauss(realNum, realDen, imagNum, imagDen);
    }

    /// <summary>Adds two fractions: a/b + c/d = (ad + bc) / bd.</summary>
    private static (BigInteger num, BigInteger den) AddFractions(BigInteger a, BigInteger b, BigInteger c, BigInteger d)
    {
        // a/b + c/d = (ad + bc) / bd
        return (a * d + b * c, b * d);
    }

    /// <summary>Multiplies two fractions: (a/b) × (c/d) = ac / bd.</summary>
    private static (BigInteger num, BigInteger den) MultiplyFractions(BigInteger a, BigInteger b, BigInteger c, BigInteger d)
    {
        // (a/b) * (c/d) = ac/bd
        return (a * c, b * d);
    }

    /// <summary>Divides two fractions: (a/b) ÷ (c/d) = ad / bc.</summary>
    /// <exception cref="DivideByZeroException">Thrown when c is zero.</exception>
    private static (BigInteger num, BigInteger den) DivideFractions(BigInteger a, BigInteger b, BigInteger c, BigInteger d)
    {
        // (a/b) / (c/d) = ad/bc
        if (c == 0) throw new DivideByZeroException();
        return (a * d, b * c);
    }

    /// <summary>
    /// Gets the complex conjugate (a/b - c/d*i).
    /// </summary>
    public Gauss Conjugate => new(A, B, -C, D);

    /// <summary>
    /// Gets the magnitude squared (|z|² = a²/b² + c²/d²) as a Gauss.
    /// </summary>
    public Gauss MagnitudeSquared
    {
        get
        {
            var (r1, r2) = MultiplyFractions(A, B, A, B);
            var (i1, i2) = MultiplyFractions(C, D, C, D);
            var (num, den) = AddFractions(r1, r2, i1, i2);
            return new Gauss(num, den, 0, 1);
        }
    }

    /// <summary>
    /// Gets the magnitude (|z|) as a double. This is an approximation — use
    /// <see cref="MagnitudeSquared"/> for exact representation.
    /// </summary>
    public double Magnitude => Math.Sqrt((double)A / (double)B * ((double)A / (double)B) + (double)C / (double)D * ((double)C / (double)D));

    /// <summary>
    /// Gets the phase angle (argument) in radians as a double approximation.
    /// </summary>
    public double Phase => Math.Atan2((double)C / (double)D, (double)A / (double)B);

    /// <summary>
    /// Gets the polar form as (magnitude, phase) double approximations.
    /// </summary>
    public (double Magnitude, double Phase) ToPolar() => (Magnitude, Phase);

    /// <summary>
    /// Creates a <see cref="Gauss"/> from polar coordinates (double approximation).
    /// The resulting value is a rational approximation of the polar form.
    /// </summary>
    public static Gauss FromPolar(double magnitude, double phase)
    {
        double re = magnitude * Math.Cos(phase);
        double im = magnitude * Math.Sin(phase);
        return FromDouble(re, im);
    }

    /// <summary>
    /// Creates a new <see cref="Gauss"/> from double real and imaginary parts.
    /// Both values are converted to their best rational approximation.
    /// </summary>
    /// <param name="real">The real part as a double.</param>
    /// <param name="imaginary">The imaginary part as a double.</param>
    public static Gauss FromDouble(double real, double imaginary)
    {
        var (rNum, rDen) = DoubleToFraction(real);
        var (iNum, iDen) = DoubleToFraction(imaginary);
        return new Gauss(rNum, rDen, iNum, iDen);
    }

    /// <summary>
    /// Gets the real part as a Gauss.
    /// </summary>
    public Gauss RealPart => new(A, B, 0, 1);

    /// <summary>
    /// Gets the imaginary part as a Gauss (without the i).
    /// </summary>
    public Gauss ImaginaryPart => new(C, D, 0, 1);

    /// <summary>
    /// Returns true if this is a real number (imaginary part is zero).
    /// </summary>
    public bool IsReal => C == 0;

    /// <summary>
    /// Returns true if this is purely imaginary (real part is zero, imaginary non-zero).
    /// </summary>
    public bool IsPurelyImaginary => A == 0 && C != 0;

    /// <summary>
    /// Returns true if this represents an integer (both parts are integers with zero imaginary).
    /// </summary>
    public bool IsInteger => B == 1 && C == 0;

    /// <summary>
    /// Returns true if this represents a Gaussian integer (both parts are integers).
    /// </summary>
    public bool IsGaussianInteger => B == 1 && D == 1;

    /// <summary>
    /// The imaginary unit i.
    /// </summary>
    public static Gauss I => new(0, 1, 1, 1);

    /// <summary>
    /// Zero.
    /// </summary>
    public static Gauss Zero => new(0, 1, 0, 1);

    /// <summary>
    /// One.
    /// </summary>
    public static Gauss One => new(1, 1, 0, 1);

    /// <summary>
    /// Negative one.
    /// </summary>
    public static Gauss MinusOne => new(-1, 1, 0, 1);

    /// <summary>
    /// Modulo operation for real GaussianRationals.
    /// </summary>
    public static Gauss operator %(Gauss left, Gauss right)
    {
        if (!left.IsReal || !right.IsReal)
            throw new InvalidOperationException("Modulo operation only supported for real numbers");
        if (right.A == 0)
            throw new DivideByZeroException("Cannot compute modulo with zero divisor");

        // (a/b) % (c/d) = ((a*d) % (c*b)) / (b*d)
        var num = (left.A * right.B) % (right.A * left.B);
        var den = left.B * right.B;
        return new Gauss(num, den, 0, 1);
    }

    /// <summary>
    /// Returns the absolute value (magnitude) as a Gauss.
    /// For real numbers, returns the absolute value exactly.
    /// For complex numbers, returns the magnitude squared (use Magnitude property for double).
    /// </summary>
    public static Gauss Abs(Gauss value)
    {
        if (value.IsReal)
        {
            return value.A >= 0 ? value : -value;
        }
        // For complex, return magnitude squared to stay in rationals
        return value.MagnitudeSquared;
    }

    /// <summary>
    /// Returns the sign of the real part: -1, 0, or 1.
    /// </summary>
    public static int Sign(Gauss value)
    {
        return value.A.Sign;
    }

    /// <summary>
    /// Returns the floor of the real part (largest integer <= real part).
    /// Only valid for real GaussianRationals.
    /// </summary>
    public static Gauss Floor(Gauss value)
    {
        if (!value.IsReal)
            throw new InvalidOperationException("Floor only supported for real numbers");

        // Floor of a/b
        if (value.B == 1) return value;
        var floor = value.A / value.B;
        if (value.A < 0 && value.A % value.B != 0)
            floor--;
        return new Gauss(floor);
    }

    /// <summary>
    /// Returns the ceiling of the real part (smallest integer >= real part).
    /// Only valid for real GaussianRationals.
    /// </summary>
    public static Gauss Ceiling(Gauss value)
    {
        if (!value.IsReal)
            throw new InvalidOperationException("Ceiling only supported for real numbers");

        if (value.B == 1) return value;
        var ceil = value.A / value.B;
        if (value.A > 0 && value.A % value.B != 0)
            ceil++;
        return new Gauss(ceil);
    }

    /// <summary>
    /// Returns the truncated integer part (rounds toward zero).
    /// Only valid for real GaussianRationals.
    /// </summary>
    public static Gauss Truncate(Gauss value)
    {
        if (!value.IsReal)
            throw new InvalidOperationException("Truncate only supported for real numbers");

        return new Gauss(value.A / value.B);
    }

    /// <summary>
    /// Raises the Gauss to an integer power.
    /// </summary>
    public static Gauss Pow(Gauss baseValue, int exponent)
    {
        if (exponent == 0) return One;
        if (exponent == 1) return baseValue;

        if (exponent < 0)
        {
            baseValue = One / baseValue;
            exponent = -exponent;
        }

        var result = One;
        var current = baseValue;

        while (exponent > 0)
        {
            if ((exponent & 1) == 1)
                result *= current;
            current *= current;
            exponent >>= 1;
        }

        return result;
    }

    /// <summary>
    /// Returns the minimum of two GaussianRationals (compared by real part).
    /// </summary>
    public static Gauss Min(Gauss a, Gauss b)
    {
        return a <= b ? a : b;
    }

    /// <summary>
    /// Returns the maximum of two GaussianRationals (compared by real part).
    /// </summary>
    public static Gauss Max(Gauss a, Gauss b)
    {
        return a >= b ? a : b;
    }

    /// <summary>
    /// Clamps the value between min and max (compared by real part).
    /// </summary>
    public static Gauss Clamp(Gauss value, Gauss min, Gauss max)
    {
        if (min > max)
            throw new ArgumentException("min must be less than or equal to max");
        if (value < min) return min;
        if (value > max) return max;
        return value;
    }

    /// <summary>
    /// Returns the reciprocal (1/z).
    /// </summary>
    public Gauss Reciprocal => One / this;

    /// <summary>
    /// Gets the norm (squared absolute value) as a <see cref="Gauss"/>.
    /// Equivalent to <see cref="MagnitudeSquared"/> but follows the mathematical convention
    /// used in Gaussian integer/rational theory.
    /// </summary>
    /// <remarks>
    /// For a Gaussian rational a/b + (c/d)i, the norm is (a/b)² + (c/d)².
    /// </remarks>
    public Gauss Norm => MagnitudeSquared;

    /// <summary>
    /// Gets the multiplicative inverse (1/z).
    /// Equivalent to <see cref="Reciprocal"/>.
    /// </summary>
    public Gauss Inverse => Reciprocal;

    /// <summary>
    /// Returns the imaginary unit i = Gauss(0, 1, 1, 1).
    /// </summary>
    public static Gauss Eye() => I;

    /// <summary>
    /// Returns the four units of Q[i]: [1, -1, i, -i].
    /// </summary>
    public static Gauss[] GaussUnits() => [One, MinusOne, I, -I];

    /// <summary>
    /// Returns a list of this Gauss's three non-trivial associates (multiplied by -1, i, -i).
    /// </summary>
    /// <remarks>
    /// Two Gaussian rationals are associates if one equals the other times a unit.
    /// Every nonzero Gaussian rational has exactly four associates (including itself).
    /// This method returns the three associates that are not equal to this value.
    /// </remarks>
    public Gauss[] Associates() => [-this, this * I, this * -I];

    /// <summary>
    /// Returns true if <paramref name="other"/> is an associate of this Gaussian rational.
    /// </summary>
    /// <param name="other">The Gaussian rational to test.</param>
    public bool IsAssociate(Gauss other)
    {
        if (other.IsZero) return IsZero;
        var q = this / other;
        // Check if q is a unit (1, -1, i, or -i)
        foreach (var unit in GaussUnits())
        {
            if (q == unit) return true;
        }
        return false;
    }

    /// <summary>
    /// Returns true if this value is zero.
    /// </summary>
    public bool IsZero => A == 0 && C == 0;

    /// <summary>
    /// Returns true if this value is one.
    /// </summary>
    public bool IsOne => A == 1 && B == 1 && C == 0;

    /// <summary>
    /// Returns true if this is a negative real number.
    /// </summary>
    public bool IsNegative => IsReal && A < 0;

    /// <summary>
    /// Returns true if this is a positive real number.
    /// </summary>
    public bool IsPositive => IsReal && A > 0;

    #endregion

    #region Equality

    /// <summary>
    /// Determines whether this value is equal to another <see cref="Gauss"/>.
    /// Because values are always stored in normalized form, this is a direct comparison
    /// of all four components.
    /// </summary>
    public bool Equals(Gauss other)
    {
        return A == other.A && B == other.B && C == other.C && D == other.D;
    }

    /// <inheritdoc/>
    public override bool Equals(object? obj)
    {
        return obj is Gauss other && Equals(other);
    }

    /// <inheritdoc/>
    public override int GetHashCode()
    {
        return HashCode.Combine(A, B, C, D);
    }

    /// <summary>Returns <see langword="true"/> if the two values are equal.</summary>
    public static bool operator ==(Gauss left, Gauss right) => left.Equals(right);

    /// <summary>Returns <see langword="true"/> if the two values are not equal.</summary>
    public static bool operator !=(Gauss left, Gauss right) => !left.Equals(right);

    #endregion

    #region Comparison

    /// <summary>
    /// Compares based on the real part (a/b). For complex numbers with equal real parts,
    /// compares by imaginary part.
    /// </summary>
    /// <inheritdoc/>
    /// <remarks>
    /// Orders primarily by real part (A/B), breaking ties by imaginary part (C/D).
    /// Cross-multiplication is used to avoid floating-point arithmetic.
    /// </remarks>
    public int CompareTo(Gauss other)
    {
        // Compare real parts: a/b vs e/f  =>  a*f vs e*b
        var realCompare = (A * other.B).CompareTo(other.A * B);
        if (realCompare != 0) return realCompare;

        // If real parts equal, compare imaginary parts: c/d vs g/h  =>  c*h vs g*d
        return (C * other.D).CompareTo(other.C * D);
    }

    /// <inheritdoc/>
    public int CompareTo(object? obj)
    {
        if (obj is null) return 1;
        if (obj is Gauss other) return CompareTo(other);
        throw new ArgumentException($"Object must be of type {nameof(Gauss)}");
    }

    /// <summary>Returns <see langword="true"/> if <paramref name="left"/> is less than <paramref name="right"/>.</summary>
    public static bool operator <(Gauss left, Gauss right) => left.CompareTo(right) < 0;

    /// <summary>Returns <see langword="true"/> if <paramref name="left"/> is greater than <paramref name="right"/>.</summary>
    public static bool operator >(Gauss left, Gauss right) => left.CompareTo(right) > 0;

    /// <summary>Returns <see langword="true"/> if <paramref name="left"/> is less than or equal to <paramref name="right"/>.</summary>
    public static bool operator <=(Gauss left, Gauss right) => left.CompareTo(right) <= 0;

    /// <summary>Returns <see langword="true"/> if <paramref name="left"/> is greater than or equal to <paramref name="right"/>.</summary>
    public static bool operator >=(Gauss left, Gauss right) => left.CompareTo(right) >= 0;

    #endregion

    #region IFormattable

    /// <summary>
    /// Formats the Gauss using the specified format.
    /// Supported formats:
    /// - "G" or null: Default human-readable format (e.g., "1 & 1/2 + 3i")
    /// - "R": Raw vector format (e.g., "<3,2,3,1>")
    /// - "D" or "F": Decimal format (e.g., "1.5 + 3i")
    /// - "I": Improper fraction format (e.g., "3/2 + 3i")
    /// </summary>
    public string ToString(string? format, IFormatProvider? formatProvider = null)
    {
        if (string.IsNullOrEmpty(format)) format = "G";

        return format.ToUpperInvariant() switch
        {
            "G" => ToString(),
            "R" => ToRawString(),
            "D" or "F" => ToDecimalString(),
            "I" => ToImproperFractionString(),
            _ => throw new FormatException($"The '{format}' format string is not supported.")
        };
    }

    /// <summary>
    /// Returns a string using improper fractions (e.g. <c>"3/2"</c> instead of
    /// <c>"1 &amp; 1/2"</c>). Useful when mixed-fraction notation is undesirable.
    /// </summary>
    public string ToImproperFractionString()
    {
        string realPart = B == 1 ? A.ToString() : $"{A}/{B}";
        string imagPart = FormatImaginaryImproper(C, D);

        if (C == 0) return realPart;
        if (A == 0) return imagPart;

        if (C > 0)
            return $"{realPart} + {imagPart}";
        else
            return $"{realPart} - {FormatImaginaryImproper(-C, D)}";
    }

    /// <summary>
    /// Formats the imaginary coefficient as an improper fraction followed by "i".
    /// </summary>
    private static string FormatImaginaryImproper(BigInteger num, BigInteger den)
    {
        if (num == 0) return "0";
        if (num == 1 && den == 1) return "i";
        if (num == -1 && den == 1) return "-i";
        if (den == 1) return $"{num}i";
        return $"{num}/{den} i";
    }

    #endregion

    #region Parsing

    /// <summary>
    /// Parses a <see cref="Gauss"/> from the canonical comma-separated form
    /// <c>"a,b,c,d"</c> (e.g. <c>"3,2,1,4"</c> for the value 3/2 + 1/4 i).
    /// </summary>
    /// <param name="s">The string to parse.</param>
    /// <exception cref="FormatException">
    /// Thrown if <paramref name="s"/> does not contain exactly four comma-separated integers.
    /// </exception>
    public static Gauss Parse(string s)
    {
        var parts = s.Split(',');
        if (parts.Length != 4)
            throw new FormatException("Expected format: a,b,c,d");

        return new Gauss(
            BigInteger.Parse(parts[0].Trim()),
            BigInteger.Parse(parts[1].Trim()),
            BigInteger.Parse(parts[2].Trim()),
            BigInteger.Parse(parts[3].Trim())
        );
    }

    /// <summary>
    /// Attempts to parse a <see cref="Gauss"/> from the canonical form
    /// <c>"a,b,c,d"</c>. Returns <see langword="false"/> on failure without throwing.
    /// </summary>
    /// <param name="s">The string to parse.</param>
    /// <param name="result">
    /// When this method returns <see langword="true"/>, contains the parsed value;
    /// otherwise, <see langword="default"/>.
    /// </param>
    /// <returns><see langword="true"/> if parsing succeeded; otherwise <see langword="false"/>.</returns>
    public static bool TryParse(string s, out Gauss result)
    {
        result = default;
        var parts = s.Split(',');
        if (parts.Length != 4) return false;

        if (!BigInteger.TryParse(parts[0].Trim(), out var a)) return false;
        if (!BigInteger.TryParse(parts[1].Trim(), out var b)) return false;
        if (!BigInteger.TryParse(parts[2].Trim(), out var c)) return false;
        if (!BigInteger.TryParse(parts[3].Trim(), out var d)) return false;

        try
        {
            result = new Gauss(a, b, c, d);
            return true;
        }
        catch
        {
            return false;
        }
    }

    #endregion
}
